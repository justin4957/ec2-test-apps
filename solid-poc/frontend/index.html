<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solid Authentication - Location Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            width: 100%;
            padding: 40px;
        }

        /* Header with connection status */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .header h1 {
            color: #333;
            font-size: 28px;
            flex: 1;
            min-width: 250px;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            border-radius: 25px;
            background: #f0f0f0;
            font-size: 14px;
            font-weight: 600;
        }

        .connection-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ccc;
            transition: all 0.3s ease;
        }

        .connection-dot.connected {
            background: #4caf50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
            animation: pulse 2s infinite;
        }

        .connection-dot.connecting {
            background: #ff9800;
            animation: blink 1s infinite;
        }

        .connection-dot.error {
            background: #f44336;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        /* Session Card */
        .session-card {
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            border: 2px solid #667eea;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            display: none;
        }

        .session-card.active {
            display: block;
        }

        .session-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .session-details {
            flex: 1;
            min-width: 200px;
        }

        .session-details h3 {
            color: #667eea;
            font-size: 16px;
            margin-bottom: 8px;
        }

        .session-details p {
            color: #666;
            font-size: 14px;
            word-break: break-all;
        }

        .session-actions {
            display: flex;
            gap: 10px;
        }

        /* Sections */
        .section {
            margin-bottom: 30px;
            padding: 25px;
            border: 2px solid #e0e0e0;
            border-radius: 15px;
            background: #f9f9f9;
            transition: all 0.3s ease;
        }

        .section:hover {
            border-color: #667eea40;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.1);
        }

        .section.active {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea05 0%, #764ba205 100%);
        }

        .section h2 {
            color: #444;
            margin-bottom: 15px;
            font-size: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .step-number {
            background: #667eea;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 700;
        }

        .step-number.completed {
            background: #4caf50;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ccc;
            transition: all 0.3s ease;
        }

        .status-indicator.active {
            background: #4caf50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
            animation: pulse 2s infinite;
        }

        .status-indicator.loading {
            background: #ff9800;
            animation: blink 1s infinite;
        }

        .status-indicator.error {
            background: #f44336;
        }

        /* Buttons */
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 14px 32px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-right: 10px;
            margin-bottom: 10px;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        button:disabled::before {
            display: none;
        }

        button.secondary {
            background: #6c757d;
        }

        button.secondary:hover {
            box-shadow: 0 8px 20px rgba(108, 117, 125, 0.4);
        }

        button.danger {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
        }

        button.danger:hover {
            box-shadow: 0 8px 20px rgba(244, 67, 54, 0.4);
        }

        button.success {
            background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);
        }

        /* Loading Button State */
        button.loading {
            pointer-events: none;
            position: relative;
            color: transparent;
        }

        button.loading::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            top: 50%;
            left: 50%;
            margin-left: -8px;
            margin-top: -8px;
            border: 3px solid white;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Input Fields */
        input {
            width: 100%;
            padding: 14px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 15px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        /* Provider Selection */
        .provider-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .provider-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .provider-card:hover {
            border-color: #667eea;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }

        .provider-card.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea10 0%, #764ba210 100%);
        }

        .provider-card h4 {
            color: #333;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .provider-card p {
            color: #666;
            font-size: 13px;
            margin-bottom: 12px;
        }

        .provider-badge {
            display: inline-block;
            background: #667eea20;
            color: #667eea;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }

        /* Profile Card */
        .profile-card {
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 25px;
            background: white;
            border-radius: 12px;
            margin-top: 15px;
            border: 2px solid #e0e0e0;
        }

        .profile-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid #667eea;
        }

        .profile-placeholder {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 32px;
            font-weight: 700;
        }

        .profile-info {
            flex: 1;
        }

        .profile-info h3 {
            color: #333;
            margin-bottom: 5px;
            font-size: 18px;
        }

        .profile-info p {
            color: #666;
            font-size: 14px;
            word-break: break-all;
            margin-bottom: 8px;
        }

        .profile-link {
            color: #667eea;
            text-decoration: none;
            font-size: 13px;
            font-weight: 600;
        }

        .profile-link:hover {
            text-decoration: underline;
        }

        /* Alert Messages */
        .alert {
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .alert.success {
            background: #4caf5015;
            border: 2px solid #4caf50;
            color: #2e7d32;
        }

        .alert.error {
            background: #f4433615;
            border: 2px solid #f44336;
            color: #c62828;
        }

        .alert.info {
            background: #2196f315;
            border: 2px solid #2196f3;
            color: #1565c0;
        }

        .alert.warning {
            background: #ff980015;
            border: 2px solid #ff9800;
            color: #e65100;
        }

        .alert-icon {
            font-size: 20px;
        }

        /* Activity Log */
        .log {
            background: #1e1e1e;
            color: #00ff00;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            max-height: 350px;
            overflow-y: auto;
            margin-top: 15px;
        }

        .log::-webkit-scrollbar {
            width: 8px;
        }

        .log::-webkit-scrollbar-track {
            background: #2a2a2a;
        }

        .log::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }

        .log-entry {
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .log-entry.error {
            color: #ff6b6b;
        }

        .log-entry.success {
            color: #51cf66;
        }

        .log-entry.info {
            color: #4dabf7;
        }

        .log-entry.warning {
            color: #ffd43b;
        }

        .log-timestamp {
            color: #888;
            margin-right: 10px;
        }

        /* Data Display */
        .data-display {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-top: 15px;
            max-height: 250px;
            overflow-y: auto;
            border: 2px solid #e0e0e0;
        }

        .data-display pre {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            white-space: pre-wrap;
            word-break: break-all;
            color: #333;
        }

        .hidden {
            display: none;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 25px;
            }

            .header {
                flex-direction: column;
                align-items: flex-start;
            }

            .header h1 {
                font-size: 24px;
            }

            .connection-status {
                width: 100%;
                justify-content: center;
            }

            .provider-grid {
                grid-template-columns: 1fr;
            }

            .profile-card {
                flex-direction: column;
                text-align: center;
            }

            .session-info {
                flex-direction: column;
            }

            .session-actions {
                width: 100%;
                flex-direction: column;
            }

            .session-actions button {
                width: 100%;
                margin: 0 0 10px 0;
            }

            button {
                width: 100%;
                margin: 0 0 10px 0;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 20px;
                border-radius: 15px;
            }

            .section {
                padding: 18px;
            }

            .header h1 {
                font-size: 22px;
            }
        }

        /* Collapsible Sections */
        .collapsible-header {
            cursor: pointer;
            user-select: none;
        }

        .collapsible-header::after {
            content: '‚ñº';
            float: right;
            font-size: 12px;
            transition: transform 0.3s ease;
        }

        .collapsible-header.collapsed::after {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .collapsible-content.collapsed {
            max-height: 0;
        }

        /* Settings UI Styles */
        .settings-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            flex-wrap: wrap;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
        }

        .settings-tab {
            background: transparent;
            color: #666;
            border: none;
            padding: 10px 20px;
            border-radius: 8px 8px 0 0;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }

        .settings-tab:hover {
            background: #f5f5f5;
            color: #333;
            transform: none;
            box-shadow: none;
        }

        .settings-tab.active {
            background: #f5f5f5;
            color: #667eea;
            border-bottom: 3px solid #667eea;
        }

        .settings-tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .settings-tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .settings-group {
            background: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .settings-group h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .settings-group.danger-zone {
            border-color: #ffebee;
            background: #fff5f5;
        }

        .settings-group.danger-zone h3 {
            color: #d32f2f;
        }

        .info-message {
            background: white;
            border: 1px solid #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .info-message p {
            color: #666;
            font-size: 14px;
            line-height: 1.6;
            margin: 0;
        }

        .info-message p + p {
            margin-top: 10px;
        }

        .info-message code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #d32f2f;
        }

        .info-message ul {
            margin: 0;
            padding-left: 20px;
        }

        .info-message li {
            color: #666;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .info-message strong {
            color: #333;
        }

        /* Responsive Settings Tabs */
        @media (max-width: 768px) {
            .settings-tabs {
                gap: 5px;
            }

            .settings-tab {
                padding: 8px 12px;
                font-size: 12px;
                flex: 1;
                min-width: 80px;
                text-align: center;
            }
        }

        @media (max-width: 480px) {
            .settings-tabs {
                flex-direction: column;
                gap: 5px;
            }

            .settings-tab {
                width: 100%;
                border-radius: 8px;
                border-bottom: none;
                border-left: 3px solid transparent;
            }

            .settings-tab.active {
                border-bottom: none;
                border-left: 3px solid #667eea;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header with Connection Status -->
        <div class="header">
            <h1>üîê Solid Authentication</h1>
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <div class="connection-status">
                    <div class="connection-dot" id="connection-dot"></div>
                    <span id="connection-text">Not Connected</span>
                </div>
                <div class="connection-status" id="offline-status">
                    <div class="connection-dot" id="offline-dot"></div>
                    <span id="offline-text">Checking...</span>
                </div>
            </div>
        </div>
        <p class="subtitle">Location Tracker - Solid Pod Integration Proof-of-Concept</p>

        <!-- Session Card (shown when authenticated) -->
        <div class="session-card" id="session-card">
            <div class="session-info">
                <div class="session-details">
                    <h3>‚úì Active Session</h3>
                    <p id="session-webid">WebID: Not loaded</p>
                </div>
                <div class="session-actions">
                    <button class="danger" onclick="logout()">Logout</button>
                </div>
            </div>
        </div>

        <!-- Step 1: Provider Selection -->
        <div class="section" id="section-provider">
            <h2>
                <span class="step-number" id="step-1">1</span>
                <span>Choose Solid Provider</span>
                <span class="status-indicator" id="status-provider"></span>
            </h2>

            <div class="provider-grid">
                <div class="provider-card" onclick="selectProvider('https://solidcommunity.net')">
                    <h4>SolidCommunity.net</h4>
                    <p>Free public Pod provider</p>
                    <span class="provider-badge">Recommended</span>
                </div>
                <div class="provider-card" onclick="selectProvider('https://login.inrupt.com')">
                    <h4>Inrupt PodSpaces</h4>
                    <p>Enterprise-ready Pods</p>
                    <span class="provider-badge">Developer Preview</span>
                </div>
                <div class="provider-card" onclick="selectProvider('https://solidweb.org')">
                    <h4>SolidWeb.org</h4>
                    <p>Community provider</p>
                    <span class="provider-badge">Community</span>
                </div>
            </div>

            <div style="margin-top: 20px;">
                <input type="text" id="issuer-input" placeholder="Or enter custom provider URL" value="https://solidcommunity.net">
            </div>
        </div>

        <!-- Step 2: Authentication -->
        <div class="section" id="section-auth">
            <h2>
                <span class="step-number" id="step-2">2</span>
                <span>Authenticate with Provider</span>
                <span class="status-indicator" id="status-auth"></span>
            </h2>
            <div id="auth-alert"></div>
            <button id="btn-login" onclick="login()">Login with Solid</button>
        </div>

        <!-- Step 3: Read WebID Profile -->
        <div class="section" id="section-profile">
            <h2>
                <span class="step-number" id="step-3">3</span>
                <span>WebID Profile</span>
                <span class="status-indicator" id="status-profile"></span>
            </h2>
            <div id="profile-data"></div>
        </div>

        <!-- Step 4: Write Location Data -->
        <div class="section" id="section-write">
            <h2>
                <span class="step-number" id="step-4">4</span>
                <span>Write Location to Pod</span>
                <span class="status-indicator" id="status-write"></span>
            </h2>
            <button id="btn-write" onclick="writeLocation()" disabled>Write Test Location</button>
            <div id="write-result"></div>
        </div>

        <!-- Step 5: Read Location Data -->
        <div class="section" id="section-read">
            <h2>
                <span class="step-number" id="step-5">5</span>
                <span>Read Location from Pod</span>
                <span class="status-indicator" id="status-read"></span>
            </h2>
            <button id="btn-read" onclick="readLocation()" disabled>Read Location Data</button>
            <div id="read-result"></div>
        </div>

        <!-- Step 6: Settings & Preferences -->
        <div class="section" id="section-settings">
            <h2>
                <span class="step-number" id="step-6">‚öôÔ∏è</span>
                <span>Settings & Preferences</span>
                <span class="status-indicator" id="status-settings"></span>
            </h2>
            <p style="color: #666; margin-bottom: 20px; font-size: 14px;">
                Manage your Solid Pod connection, data, and privacy preferences
            </p>

            <!-- Settings Tabs -->
            <div class="settings-tabs">
                <button class="settings-tab active" onclick="switchSettingsTab('profile')">
                    üë§ Profile
                </button>
                <button class="settings-tab" onclick="switchSettingsTab('storage')">
                    üíæ Storage
                </button>
                <button class="settings-tab" onclick="switchSettingsTab('data')">
                    üì¶ Data Management
                </button>
                <button class="settings-tab" onclick="switchSettingsTab('privacy')">
                    üîí Privacy
                </button>
                <button class="settings-tab" onclick="switchSettingsTab('social')">
                    üë• Social
                </button>
                <button class="settings-tab" onclick="switchSettingsTab('session')">
                    üîë Session
                </button>
            </div>

            <!-- Profile Tab -->
            <div class="settings-tab-content active" id="settings-profile">
                <div class="settings-group">
                    <h3>WebID Profile Information</h3>
                    <div id="settings-profile-info" class="info-message">
                        <p>Please log in to view your profile information.</p>
                    </div>
                    <button id="btn-refresh-profile" onclick="refreshProfile()" disabled class="secondary">
                        üîÑ Refresh Profile
                    </button>
                </div>
            </div>

            <!-- Storage Tab -->
            <div class="settings-tab-content" id="settings-storage">
                <div class="settings-group">
                    <h3>Pod Storage Location</h3>
                    <div id="settings-storage-info" class="info-message">
                        <p>Please log in to view your storage information.</p>
                    </div>
                    <button id="btn-view-pod" onclick="viewPodInBrowser()" disabled class="secondary">
                        üåê Open Pod in Browser
                    </button>
                </div>

                <div class="settings-group">
                    <h3>Storage Usage</h3>
                    <div id="settings-storage-usage" class="info-message">
                        <p>Storage usage information is not available via the Solid protocol.</p>
                        <p style="margin-top: 10px; font-size: 13px;">
                            Visit your Pod provider's dashboard to view storage details.
                        </p>
                    </div>
                </div>
            </div>

            <!-- Data Management Tab -->
            <div class="settings-tab-content" id="settings-data">
                <div class="settings-group">
                    <h3>Export Location Data</h3>
                    <p style="color: #666; margin-bottom: 15px; font-size: 14px;">
                        Download all your location data from the Pod in JSON format.
                    </p>
                    <button id="btn-export-data" onclick="exportLocationData()" disabled class="secondary">
                        üì• Export All Locations
                    </button>
                    <div id="export-result"></div>
                </div>

                <div class="settings-group">
                    <h3>Import Location Data</h3>
                    <p style="color: #666; margin-bottom: 15px; font-size: 14px;">
                        Upload location data to your Pod (JSON or Turtle format).
                    </p>
                    <input type="file" id="file-import" accept=".json,.ttl,.turtle" style="margin-bottom: 10px;" disabled>
                    <button id="btn-import-data" onclick="importLocationData()" disabled class="secondary">
                        üì§ Import Locations
                    </button>
                    <div id="import-result"></div>
                </div>

                <div class="settings-group danger-zone">
                    <h3>‚ö†Ô∏è Danger Zone</h3>
                    <p style="color: #666; margin-bottom: 15px; font-size: 14px;">
                        Delete all location data from your Pod. This action cannot be undone.
                    </p>
                    <button id="btn-delete-all" onclick="confirmDeleteAll()" disabled class="danger">
                        üóëÔ∏è Delete All Location Data
                    </button>
                    <div id="delete-result"></div>
                </div>
            </div>

            <!-- Privacy Tab -->
            <div class="settings-tab-content" id="settings-privacy">
                <div class="settings-group">
                    <h3>Container Access Overview</h3>
                    <p style="color: #666; margin-bottom: 15px; font-size: 14px;">
                        Your location data is stored in <code>/private/location-tracker/</code>
                    </p>
                    <div id="settings-privacy-info" class="info-message">
                        <p>Loading access information...</p>
                    </div>
                    <button id="btn-refresh-access" onclick="refreshAccessInfo()" class="secondary" style="margin-top: 15px;">
                        üîÑ Refresh Access Info
                    </button>
                </div>

                <div class="settings-group">
                    <h3>Grant Access to Others</h3>
                    <p style="color: #666; margin-bottom: 15px; font-size: 14px;">
                        Share your location data with specific people or make it public.
                    </p>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #444;">Grant Public Access:</label>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <button onclick="setPublicAccess('read')" class="secondary">
                                üëÅÔ∏è Make Public (Read-Only)
                            </button>
                            <button onclick="setPublicAccess('write')" class="secondary">
                                ‚úèÔ∏è Make Public (Read-Write)
                            </button>
                            <button onclick="setPublicAccess('none')" class="secondary">
                                üîí Make Private
                            </button>
                        </div>
                    </div>

                    <div style="margin-top: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #444;">Grant Access to Specific Person:</label>
                        <input type="text" id="input-grant-webid" placeholder="Enter WebID (e.g., https://example.solidcommunity.net/profile/card#me)">
                        <div style="display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap;">
                            <button id="btn-grant-read" onclick="grantAgentAccess('read')" class="secondary">
                                ‚ûï Grant Read Access
                            </button>
                            <button id="btn-grant-write" onclick="grantAgentAccess('write')" class="secondary">
                                ‚ûï Grant Write Access
                            </button>
                        </div>
                    </div>
                    <div id="grant-result"></div>
                </div>

                <div class="settings-group">
                    <h3>Current Access Permissions</h3>
                    <p style="color: #666; margin-bottom: 15px; font-size: 14px;">
                        People who currently have access to your location data.
                    </p>
                    <div id="current-permissions-list" class="info-message">
                        <p>Loading permissions...</p>
                    </div>
                </div>

                <div class="settings-group">
                    <h3>Revoke Access</h3>
                    <p style="color: #666; margin-bottom: 15px; font-size: 14px;">
                        Remove access from a specific person.
                    </p>
                    <input type="text" id="input-revoke-webid" placeholder="Enter WebID to revoke access">
                    <button id="btn-revoke-access" onclick="revokeAgentAccess()" class="secondary">
                        ‚ùå Revoke All Access
                    </button>
                    <div id="revoke-result"></div>
                </div>

                <div class="settings-group">
                    <h3>Share Link</h3>
                    <p style="color: #666; margin-bottom: 15px; font-size: 14px;">
                        Generate a link to share your location data container.
                    </p>
                    <button onclick="generateShareLink()" class="secondary">
                        üîó Generate Share Link
                    </button>
                    <div id="share-link-result"></div>
                </div>
            </div>

            <!-- Social Tab -->
            <div class="settings-tab-content" id="settings-social">
                <div class="settings-group">
                    <h3>üë• Friends List</h3>
                    <p style="color: #666; margin-bottom: 15px; font-size: 14px;">
                        Manage your friends and social connections via FOAF (Friend of a Friend).
                    </p>
                    <div id="friends-list" class="info-message">
                        <p>Loading friends...</p>
                    </div>
                </div>

                <div class="settings-group">
                    <h3>‚ûï Add Friend</h3>
                    <p style="color: #666; margin-bottom: 15px; font-size: 14px;">
                        Add a friend by their WebID to see their shared location data.
                    </p>
                    <input type="text" id="input-friend-webid" placeholder="Enter WebID (e.g., https://friend.solidcommunity.net/profile/card#me)">
                    <button id="btn-add-friend" onclick="addFriend()" class="secondary">
                        ‚ûï Add Friend
                    </button>
                    <div id="add-friend-result"></div>
                </div>

                <div class="settings-group">
                    <h3>üìç Social Feed</h3>
                    <p style="color: #666; margin-bottom: 15px; font-size: 14px;">
                        View location data shared by your friends.
                    </p>
                    <button id="btn-refresh-feed" onclick="refreshSocialFeed()" class="secondary">
                        üîÑ Refresh Feed
                    </button>
                    <div id="social-feed" class="info-message" style="margin-top: 15px;">
                        <p>No activities yet. Add friends to see their shared locations!</p>
                    </div>
                </div>

                <div class="settings-group">
                    <h3>üîç Discover Friend</h3>
                    <p style="color: #666; margin-bottom: 15px; font-size: 14px;">
                        Look up a friend's profile information by WebID.
                    </p>
                    <input type="text" id="input-discover-webid" placeholder="Enter WebID to discover">
                    <button id="btn-discover-friend" onclick="discoverFriend()" class="secondary">
                        üîç Discover Profile
                    </button>
                    <div id="discover-result"></div>
                </div>
            </div>

            <!-- Session Tab -->
            <div class="settings-tab-content" id="settings-session">
                <div class="settings-group">
                    <h3>Active Session</h3>
                    <div id="settings-session-info" class="info-message">
                        <p>No active session.</p>
                    </div>
                </div>

                <div class="settings-group">
                    <h3>Session Management</h3>
                    <p style="color: #666; margin-bottom: 15px; font-size: 14px;">
                        Manage your current authentication session.
                    </p>
                    <button id="btn-refresh-session" onclick="refreshSession()" disabled class="secondary">
                        üîÑ Refresh Session
                    </button>
                    <button id="btn-logout-settings" onclick="logout()" disabled class="danger" style="margin-left: 10px;">
                        üö™ Logout
                    </button>
                </div>

                <div class="settings-group">
                    <h3>Connected Applications</h3>
                    <div class="info-message">
                        <p><strong>Currently Connected:</strong></p>
                        <ul style="margin-top: 10px; padding-left: 20px;">
                            <li>Location Tracker PoC</li>
                        </ul>
                        <p style="margin-top: 15px; font-size: 13px; color: #666;">
                            To revoke access to this application, use your Pod provider's
                            authorization management interface.
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Offline Sync Status -->
        <div class="section" id="section-sync">
            <h2>
                <span class="step-number">üîÑ</span>
                <span>Offline Sync Status</span>
                <span class="status-indicator" id="status-sync"></span>
            </h2>
            <div id="sync-stats" class="info-message" style="margin-bottom: 15px;">
                <p><strong>Sync Statistics:</strong></p>
                <p id="sync-stats-content">Initializing...</p>
            </div>
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button id="btn-sync" onclick="manualSync()" style="flex: 1; min-width: 150px;">
                    üîÑ Sync Now
                </button>
                <button id="btn-view-queue" onclick="viewSyncQueue()" style="flex: 1; min-width: 150px;">
                    üìã View Queue
                </button>
                <button id="btn-clear-cache" onclick="clearOfflineCache()" class="danger" style="flex: 1; min-width: 150px;">
                    üóëÔ∏è Clear Cache
                </button>
            </div>
            <div id="sync-result" style="margin-top: 15px;"></div>
        </div>

        <!-- Activity Log -->
        <div class="section">
            <h2 class="collapsible-header" onclick="toggleLog()">
                <span>üìã Activity Log</span>
            </h2>
            <div class="collapsible-content" id="log-content">
                <div class="log" id="activity-log"></div>
            </div>
        </div>
    </div>

    <!-- Load Solid Client Libraries -->
    <script src="dist/solid-client-bundle.js"></script>
    <!-- Load Offline Storage Module -->
    <script src="offline.js"></script>
    <script>
        // Import from the bundled library (don't import 'login' to avoid naming conflict)
        const { handleIncomingRedirect, getDefaultSession, fetch: solidFetch } = solidClientAuthentication;
        const {
            getSolidDataset,
            getThing,
            getStringNoLocale,
            getUrl,
            saveSolidDatasetAt,
            createSolidDataset,
            createThing,
            setThing,
            buildThing,
            setStringNoLocale,
            setDecimal,
            setDatetime,
            createContainerAt,
            overwriteFile
        } = solidClient;

        let session = null;
        let lastWrittenLocationUrl = null;
        let isOnline = navigator.onLine;
        let serviceWorkerRegistration = null;

        // Initialize
        async function init() {
            session = getDefaultSession();

            log('Initializing Solid authentication...', 'info');

            // Initialize offline storage
            try {
                await offlineStorage.init();
                log('Offline storage initialized', 'success');
                await updateSyncStats();
            } catch (error) {
                log(`Offline storage initialization failed: ${error.message}`, 'error');
            }

            // Register Service Worker
            if ('serviceWorker' in navigator) {
                try {
                    serviceWorkerRegistration = await navigator.serviceWorker.register('/sw.js');
                    log('Service Worker registered successfully', 'success');

                    // Listen for messages from Service Worker
                    navigator.serviceWorker.addEventListener('message', handleServiceWorkerMessage);
                } catch (error) {
                    log(`Service Worker registration failed: ${error.message}`, 'warning');
                }
            }

            // Set up online/offline event listeners
            window.addEventListener('online', handleOnlineStatusChange);
            window.addEventListener('offline', handleOnlineStatusChange);
            updateOnlineStatus();

            // Handle OAuth redirect
            await handleIncomingRedirect();

            if (session.info.isLoggedIn) {
                log('Session restored from storage', 'success');
                await onLoginSuccess();
            } else {
                updateConnectionStatus('disconnected');
                log('Ready to login', 'info');
            }

            // Auto-sync when coming online
            if (isOnline) {
                setTimeout(() => autoSync(), 2000);
            }
        }

        // Provider Selection (attach to window for onclick handlers)
        window.selectProvider = function(issuer) {
            document.getElementById('issuer-input').value = issuer;
            document.querySelectorAll('.provider-card').forEach(card => {
                card.classList.remove('selected');
            });
            event.target.closest('.provider-card').classList.add('selected');
            updateStatus('status-provider', 'active');
            document.getElementById('step-1').classList.add('completed');
            log(`Selected provider: ${issuer}`, 'success');
        }

        // Login (attach to window for onclick handlers)
        window.login = async function() {
            const issuer = document.getElementById('issuer-input').value.trim();

            if (!issuer) {
                showAlert('auth-alert', 'Please enter a provider URL', 'error');
                return;
            }

            setButtonLoading('btn-login', true);
            updateConnectionStatus('connecting');
            updateStatus('status-auth', 'loading');
            log(`Initiating login with ${issuer}...`, 'info');

            try {
                await solidClientAuthentication.login({
                    oidcIssuer: issuer,
                    redirectUrl: window.location.href,
                    clientName: 'Location Tracker - Solid PoC'
                });
            } catch (error) {
                log(`Login error: ${error.message}`, 'error');
                showAlert('auth-alert', `Login failed: ${error.message}`, 'error');
                updateConnectionStatus('error');
                updateStatus('status-auth', 'error');
                setButtonLoading('btn-login', false);
            }
        }

        // Logout (attach to window for onclick handlers)
        window.logout = async function() {
            log('Logging out...', 'info');
            await session.logout();
            location.reload();
        }

        // On Login Success
        async function onLoginSuccess() {
            updateConnectionStatus('connected');
            updateStatus('status-auth', 'active');
            document.getElementById('step-2').classList.add('completed');
            setButtonLoading('btn-login', false);

            // Show session card
            document.getElementById('session-card').classList.add('active');
            document.getElementById('session-webid').textContent = `WebID: ${session.info.webId}`;

            log(`‚úì Authenticated as ${session.info.webId}`, 'success');
            showAlert('auth-alert', 'Successfully authenticated!', 'success');

            // Auto-fetch profile
            await readProfile();

            // Enable write/read buttons
            document.getElementById('btn-write').disabled = false;
            document.getElementById('btn-read').disabled = false;

            // Populate settings UI
            await populateSettings();
        }

        // Read Profile
        async function readProfile() {
            updateStatus('status-profile', 'loading');
            log('Reading WebID profile...', 'info');

            try {
                const webId = session.info.webId;
                const profileDataset = await getSolidDataset(webId, { fetch: session.fetch });
                const profile = getThing(profileDataset, webId);

                // Try multiple name predicates in order of preference
                let name = getStringNoLocale(profile, 'http://xmlns.com/foaf/0.1/name') ||
                          getStringNoLocale(profile, 'http://www.w3.org/2006/vcard/ns#fn') ||
                          getStringNoLocale(profile, 'http://schema.org/name');

                // If no name found in profile, extract username from WebID URL
                if (!name) {
                    const urlMatch = webId.match(/\/\/[^/]+\/([^/]+)/);
                    name = urlMatch ? urlMatch[1] : 'User';
                    log('Name not found in profile, using username from WebID', 'info');
                }

                updateStatus('status-profile', 'active');
                document.getElementById('step-3').classList.add('completed');
                log(`‚úì Profile loaded: ${name}`, 'success');

                // Display profile
                const profileHtml = `
                    <div class="profile-card">
                        <div class="profile-placeholder">${name.charAt(0).toUpperCase()}</div>
                        <div class="profile-info">
                            <h3>${name}</h3>
                            <p>${webId}</p>
                            <a href="${webId}" target="_blank" class="profile-link">View Full Profile ‚Üí</a>
                        </div>
                    </div>
                `;
                document.getElementById('profile-data').innerHTML = profileHtml;

            } catch (error) {
                log(`Profile read error: ${error.message}`, 'error');
                updateStatus('status-profile', 'error');
            }
        }

        // Write Location (attach to window for onclick handlers)
        window.writeLocation = async function() {
            setButtonLoading('btn-write', true);
            updateStatus('status-write', 'loading');
            log('Writing test location to Pod...', 'info');

            const locationData = {
                latitude: 37.7749,
                longitude: -122.4194,
                accuracy: 10.5,
                deviceId: 'poc-test-device',
                timestamp: Date.now()
            };

            try {
                // If online, try to write directly
                if (isOnline) {
                    try {
                        const locationUrl = await writeLocationToPod(locationData);
                        lastWrittenLocationUrl = locationUrl;

                        // Cache the location data
                        await offlineStorage.cacheLocation(locationUrl, locationData, true);

                        updateStatus('status-write', 'active');
                        document.getElementById('step-4').classList.add('completed');
                        log(`‚úì Location written to ${locationUrl}`, 'success');

                        const resultHtml = `
                            <div class="alert success">
                                <span class="alert-icon">‚úì</span>
                                <div>
                                    <strong>Location saved successfully!</strong><br>
                                    <a href="${locationUrl}" target="_blank" style="color: inherit;">${locationUrl}</a>
                                </div>
                            </div>
                        `;
                        document.getElementById('write-result').innerHTML = resultHtml;

                        await updateSyncStats();
                    } catch (writeError) {
                        // If write fails while online, queue for later
                        log(`Direct write failed, queueing for sync: ${writeError.message}`, 'warning');
                        throw writeError; // Let outer catch handle queueing
                    }
                } else {
                    // Offline - queue the operation
                    throw new Error('Offline');
                }

            } catch (error) {
                // Queue the operation for later sync
                try {
                    await offlineStorage.queueOperation({
                        type: 'writeLocation',
                        data: locationData
                    });

                    log(`‚ö† Offline - location queued for sync`, 'warning');
                    updateStatus('status-write', 'loading');

                    document.getElementById('write-result').innerHTML = `
                        <div class="alert warning">
                            <span class="alert-icon">‚è≥</span>
                            <div>
                                <strong>Queued for sync</strong><br>
                                Location will be saved when you're back online
                            </div>
                        </div>
                    `;

                    await updateSyncStats();
                } catch (queueError) {
                    log(`Failed to queue operation: ${queueError.message}`, 'error');
                    updateStatus('status-write', 'error');
                    document.getElementById('write-result').innerHTML = `
                        <div class="alert error">
                            <span class="alert-icon">‚úó</span>
                            <div><strong>Error:</strong> ${queueError.message}</div>
                        </div>
                    `;
                }
            } finally {
                setButtonLoading('btn-write', false);
            }
        }

        // Read Location (attach to window for onclick handlers)
        window.readLocation = async function() {
            if (!lastWrittenLocationUrl) {
                showAlert('read-result', 'Please write a location first', 'warning');
                return;
            }

            setButtonLoading('btn-read', true);
            updateStatus('status-read', 'loading');
            log(`Reading location from ${lastWrittenLocationUrl}...`, 'info');

            try {
                const locationDataset = await getSolidDataset(lastWrittenLocationUrl, { fetch: session.fetch });
                const location = getThing(locationDataset, lastWrittenLocationUrl + '#location');

                const lat = location.predicates['http://www.w3.org/2003/01/geo/wgs84_pos#lat'][0];
                const lng = location.predicates['http://www.w3.org/2003/01/geo/wgs84_pos#long'][0];
                const accuracy = location.predicates['http://schema.org/accuracy'][0];

                updateStatus('status-read', 'active');
                document.getElementById('step-5').classList.add('completed');
                log(`‚úì Location read successfully`, 'success');

                const resultHtml = `
                    <div class="alert success">
                        <span class="alert-icon">‚úì</span>
                        <div>
                            <strong>Location loaded!</strong><br>
                            Latitude: ${lat}<br>
                            Longitude: ${lng}<br>
                            Accuracy: ${accuracy}m
                        </div>
                    </div>
                    <div class="data-display">
                        <strong>Full Location Data:</strong>
                        <pre>${JSON.stringify(location.predicates, null, 2)}</pre>
                    </div>
                `;
                document.getElementById('read-result').innerHTML = resultHtml;

            } catch (error) {
                log(`Read error: ${error.message}`, 'error');
                updateStatus('status-read', 'error');
                document.getElementById('read-result').innerHTML = `
                    <div class="alert error">
                        <span class="alert-icon">‚úó</span>
                        <div><strong>Error:</strong> ${error.message}</div>
                    </div>
                `;
            } finally {
                setButtonLoading('btn-read', false);
            }
        }

        // Helper Functions
        function updateConnectionStatus(status) {
            const dot = document.getElementById('connection-dot');
            const text = document.getElementById('connection-text');

            dot.className = 'connection-dot';

            switch(status) {
                case 'connected':
                    dot.classList.add('connected');
                    text.textContent = 'Connected';
                    break;
                case 'connecting':
                    dot.classList.add('connecting');
                    text.textContent = 'Connecting...';
                    break;
                case 'error':
                    dot.classList.add('error');
                    text.textContent = 'Connection Error';
                    break;
                default:
                    text.textContent = 'Not Connected';
            }
        }

        function updateStatus(elementId, status) {
            const indicator = document.getElementById(elementId);
            indicator.className = 'status-indicator';
            if (status) indicator.classList.add(status);
        }

        function setButtonLoading(buttonId, isLoading) {
            const button = document.getElementById(buttonId);
            if (isLoading) {
                button.classList.add('loading');
                button.disabled = true;
            } else {
                button.classList.remove('loading');
                button.disabled = false;
            }
        }

        function showAlert(containerId, message, type) {
            const container = document.getElementById(containerId);
            const icons = {
                success: '‚úì',
                error: '‚úó',
                warning: '‚ö†',
                info: '‚Ñπ'
            };
            container.innerHTML = `
                <div class="alert ${type}">
                    <span class="alert-icon">${icons[type]}</span>
                    <div>${message}</div>
                </div>
            `;
        }

        function log(message, type = 'info') {
            const logDiv = document.getElementById('activity-log');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span>${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        window.toggleLog = function() {
            const content = document.getElementById('log-content');
            const header = event.target.closest('.collapsible-header');
            content.classList.toggle('collapsed');
            header.classList.toggle('collapsed');
        }

        // ========================================
        // SETTINGS UI FUNCTIONS
        // ========================================

        // Switch between settings tabs
        window.switchSettingsTab = function(tabName) {
            // Remove active class from all tabs and contents
            document.querySelectorAll('.settings-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.settings-tab-content').forEach(content => content.classList.remove('active'));

            // Add active class to selected tab and content
            event.target.classList.add('active');
            document.getElementById(`settings-${tabName}`).classList.add('active');

            log(`Switched to ${tabName} settings tab`, 'info');
        }

        // Populate settings when user logs in
        async function populateSettings() {
            if (!session || !session.info.isLoggedIn) {
                return;
            }

            log('Populating settings...', 'info');

            // Enable all settings buttons
            document.getElementById('btn-refresh-profile').disabled = false;
            document.getElementById('btn-view-pod').disabled = false;
            document.getElementById('btn-export-data').disabled = false;
            document.getElementById('file-import').disabled = false;
            document.getElementById('btn-import-data').disabled = false;
            document.getElementById('btn-delete-all').disabled = false;
            document.getElementById('btn-refresh-session').disabled = false;
            document.getElementById('btn-logout-settings').disabled = false;
            document.getElementById('btn-refresh-access').disabled = false;

            updateStatus('status-settings', 'active');

            // Populate profile info
            await updateProfileSettings();

            // Populate storage info
            await updateStorageSettings();

            // Populate session info
            updateSessionSettings();

            // Populate access control info
            await refreshAccessInfo();

            // Initialize social features
            await initializeSocialFeatures();
        }

        // Update profile settings tab
        async function updateProfileSettings() {
            try {
                const webId = session.info.webId;
                const profileDataset = await solidClient.getSolidDataset(webId, { fetch: session.fetch });
                const profileThing = solidClient.getThing(profileDataset, webId);

                // Try multiple predicates for name
                let name = solidClient.getStringNoLocale(profileThing, 'http://xmlns.com/foaf/0.1/name') ||
                           solidClient.getStringNoLocale(profileThing, 'http://www.w3.org/2006/vcard/ns#fn') ||
                           solidClient.getStringNoLocale(profileThing, 'http://schema.org/name');

                // Fallback to username from WebID
                if (!name) {
                    const match = webId.match(/\/\/([^.]+)\./);
                    name = match ? match[1] : 'Unknown';
                }

                const storage = solidClient.getUrl(profileThing, 'http://www.w3.org/ns/pim/space#storage');

                document.getElementById('settings-profile-info').innerHTML = `
                    <div class="profile-card" style="margin: 0;">
                        <img src="https://ui-avatars.com/api/?name=${encodeURIComponent(name)}&size=80&background=667eea&color=fff" alt="Avatar">
                        <div class="profile-info">
                            <h3 style="margin-bottom: 8px;">${name}</h3>
                            <p style="margin-bottom: 5px;"><strong>WebID:</strong> ${webId}</p>
                            <p><strong>Provider:</strong> ${new URL(webId).hostname}</p>
                        </div>
                    </div>
                `;

                log('‚úì Profile settings updated', 'success');
            } catch (error) {
                log(`‚úó Failed to update profile settings: ${error.message}`, 'error');
                document.getElementById('settings-profile-info').innerHTML = `
                    <div class="alert error">
                        <span class="alert-icon">‚úó</span>
                        <div>Failed to load profile: ${error.message}</div>
                    </div>
                `;
            }
        }

        // Update storage settings tab
        async function updateStorageSettings() {
            try {
                const webId = session.info.webId;
                const profileDataset = await solidClient.getSolidDataset(webId, { fetch: session.fetch });
                const profileThing = solidClient.getThing(profileDataset, webId);
                const storage = solidClient.getUrl(profileThing, 'http://www.w3.org/ns/pim/space#storage');

                if (storage) {
                    const containerUrl = `${storage}private/location-tracker/`;
                    document.getElementById('settings-storage-info').innerHTML = `
                        <p><strong>Pod Storage Root:</strong></p>
                        <p style="margin-top: 8px; word-break: break-all; font-family: 'Courier New', monospace; font-size: 13px; background: #f5f5f5; padding: 10px; border-radius: 5px;">
                            ${storage}
                        </p>
                        <p style="margin-top: 15px;"><strong>Location Data Container:</strong></p>
                        <p style="margin-top: 8px; word-break: break-all; font-family: 'Courier New', monospace; font-size: 13px; background: #f5f5f5; padding: 10px; border-radius: 5px;">
                            ${containerUrl}
                        </p>
                    `;
                } else {
                    document.getElementById('settings-storage-info').innerHTML = `
                        <div class="alert warning">
                            <span class="alert-icon">‚ö†</span>
                            <div>No storage location found in profile</div>
                        </div>
                    `;
                }

                log('‚úì Storage settings updated', 'success');
            } catch (error) {
                log(`‚úó Failed to update storage settings: ${error.message}`, 'error');
                document.getElementById('settings-storage-info').innerHTML = `
                    <div class="alert error">
                        <span class="alert-icon">‚úó</span>
                        <div>Failed to load storage info: ${error.message}</div>
                    </div>
                `;
            }
        }

        // Update session settings tab
        function updateSessionSettings() {
            const webId = session.info.webId;
            const sessionStart = session.info.sessionId ? 'Active' : 'Unknown';

            document.getElementById('settings-session-info').innerHTML = `
                <p><strong>Status:</strong> <span style="color: #4caf50;">‚óè Connected</span></p>
                <p style="margin-top: 10px;"><strong>WebID:</strong></p>
                <p style="margin-top: 5px; word-break: break-all; font-family: 'Courier New', monospace; font-size: 13px; background: #f5f5f5; padding: 10px; border-radius: 5px;">
                    ${webId}
                </p>
                <p style="margin-top: 15px;"><strong>Session ID:</strong> ${session.info.sessionId || 'N/A'}</p>
                <p style="margin-top: 10px;"><strong>Client ID:</strong> ${session.info.clientAppId || 'Location Tracker PoC'}</p>
            `;

            log('‚úì Session settings updated', 'success');
        }

        // Refresh profile
        window.refreshProfile = async function() {
            log('Refreshing profile...', 'info');
            setButtonLoading('btn-refresh-profile', true);

            try {
                await updateProfileSettings();
                showAlert('settings-profile', 'Profile refreshed successfully', 'success');
            } catch (error) {
                showAlert('settings-profile', `Failed to refresh profile: ${error.message}`, 'error');
            } finally {
                setButtonLoading('btn-refresh-profile', false);
            }
        }

        // Open Pod in browser
        window.viewPodInBrowser = async function() {
            try {
                const webId = session.info.webId;
                const profileDataset = await solidClient.getSolidDataset(webId, { fetch: session.fetch });
                const profileThing = solidClient.getThing(profileDataset, webId);
                const storage = solidClient.getUrl(profileThing, 'http://www.w3.org/ns/pim/space#storage');

                if (storage) {
                    const containerUrl = `${storage}private/location-tracker/`;
                    window.open(containerUrl, '_blank');
                    log(`‚úì Opening Pod in browser: ${containerUrl}`, 'success');
                } else {
                    log('‚úó No storage location found', 'error');
                }
            } catch (error) {
                log(`‚úó Failed to open Pod: ${error.message}`, 'error');
            }
        }

        // Export location data
        window.exportLocationData = async function() {
            log('Exporting location data...', 'info');
            setButtonLoading('btn-export-data', true);
            document.getElementById('export-result').innerHTML = '';

            try {
                const webId = session.info.webId;
                const profileDataset = await solidClient.getSolidDataset(webId, { fetch: session.fetch });
                const profileThing = solidClient.getThing(profileDataset, webId);
                const storage = solidClient.getUrl(profileThing, 'http://www.w3.org/ns/pim/space#storage');

                if (!storage) {
                    throw new Error('No storage location found in profile');
                }

                const containerUrl = `${storage}private/location-tracker/`;

                // Try to get container contents
                let dataset;
                try {
                    dataset = await solidClient.getSolidDataset(containerUrl, { fetch: session.fetch });
                } catch (error) {
                    // Container might not exist yet
                    log('‚úó No location data found in Pod', 'warning');
                    showAlert('export-result', 'No location data found. Write a location first!', 'warning');
                    return;
                }

                // Get all contained resources
                const resources = solidClient.getContainedResourceUrlAll(dataset);
                const locations = [];

                for (const resourceUrl of resources) {
                    if (resourceUrl.endsWith('.ttl')) {
                        try {
                            const locationDataset = await solidClient.getSolidDataset(resourceUrl, { fetch: session.fetch });
                            const locationThing = solidClient.getThing(locationDataset, `${resourceUrl}#location`);

                            if (locationThing) {
                                const latitude = solidClient.getDecimal(locationThing, 'http://www.w3.org/2003/01/geo/wgs84_pos#lat');
                                const longitude = solidClient.getDecimal(locationThing, 'http://www.w3.org/2003/01/geo/wgs84_pos#long');
                                const accuracy = solidClient.getDecimal(locationThing, 'http://schema.org/accuracy');
                                const created = solidClient.getDatetime(locationThing, 'http://purl.org/dc/terms/created');
                                const name = solidClient.getStringNoLocale(locationThing, 'http://schema.org/name');
                                const description = solidClient.getStringNoLocale(locationThing, 'http://schema.org/description');

                                locations.push({
                                    url: resourceUrl,
                                    name: name,
                                    description: description,
                                    latitude: latitude,
                                    longitude: longitude,
                                    accuracy: accuracy,
                                    timestamp: created
                                });
                            }
                        } catch (error) {
                            log(`‚ö† Skipped ${resourceUrl}: ${error.message}`, 'warning');
                        }
                    }
                }

                if (locations.length === 0) {
                    log('‚úó No location data found', 'warning');
                    showAlert('export-result', 'No location data found in your Pod', 'warning');
                    return;
                }

                // Create JSON export
                const exportData = {
                    exported: new Date().toISOString(),
                    webId: webId,
                    count: locations.length,
                    locations: locations
                };

                // Download as JSON file
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `location-data-export-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                log(`‚úì Exported ${locations.length} location(s)`, 'success');
                showAlert('export-result', `Successfully exported ${locations.length} location(s)`, 'success');

            } catch (error) {
                log(`‚úó Export failed: ${error.message}`, 'error');
                showAlert('export-result', `Export failed: ${error.message}`, 'error');
            } finally {
                setButtonLoading('btn-export-data', false);
            }
        }

        // Import location data
        window.importLocationData = async function() {
            const fileInput = document.getElementById('file-import');
            const file = fileInput.files[0];

            if (!file) {
                showAlert('import-result', 'Please select a file to import', 'warning');
                return;
            }

            log(`Importing ${file.name}...`, 'info');
            setButtonLoading('btn-import-data', true);
            document.getElementById('import-result').innerHTML = '';

            try {
                const webId = session.info.webId;
                const profileDataset = await solidClient.getSolidDataset(webId, { fetch: session.fetch });
                const profileThing = solidClient.getThing(profileDataset, webId);
                const storage = solidClient.getUrl(profileThing, 'http://www.w3.org/ns/pim/space#storage');

                if (!storage) {
                    throw new Error('No storage location found in profile');
                }

                const containerUrl = `${storage}private/location-tracker/`;

                // Ensure container exists
                try {
                    await solidClient.createContainerAt(containerUrl, { fetch: session.fetch });
                } catch (error) {
                    // Container might already exist
                }

                // Read file
                const text = await file.text();
                let data;

                if (file.name.endsWith('.json')) {
                    data = JSON.parse(text);
                    if (!data.locations || !Array.isArray(data.locations)) {
                        throw new Error('Invalid JSON format: missing locations array');
                    }

                    // Import each location
                    let imported = 0;
                    for (const location of data.locations) {
                        const timestamp = location.timestamp || new Date().toISOString();
                        const locationFileName = `imported-location-${Date.now()}-${imported}.ttl`;
                        const locationUrl = `${containerUrl}${locationFileName}`;

                        const locationData = `@prefix schema: <http://schema.org/> .
@prefix geo: <http://www.w3.org/2003/01/geo/wgs84_pos#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix dcterms: <http://purl.org/dc/terms/> .

<#location> a schema:Place, geo:Point ;
    geo:lat "${location.latitude}"^^xsd:decimal ;
    geo:long "${location.longitude}"^^xsd:decimal ;
    schema:accuracy "${location.accuracy || 0}"^^xsd:decimal ;
    dcterms:created "${timestamp}"^^xsd:dateTime ;
    schema:name "${location.name || 'Imported Location'}" ;
    schema:description "${location.description || 'Imported from file'}" .
`;

                        await solidClient.overwriteFile(
                            locationUrl,
                            new Blob([locationData], { type: 'text/turtle' }),
                            { fetch: session.fetch, contentType: 'text/turtle' }
                        );

                        imported++;
                    }

                    log(`‚úì Imported ${imported} location(s)`, 'success');
                    showAlert('import-result', `Successfully imported ${imported} location(s)`, 'success');

                } else {
                    throw new Error('Unsupported file format. Please use JSON.');
                }

            } catch (error) {
                log(`‚úó Import failed: ${error.message}`, 'error');
                showAlert('import-result', `Import failed: ${error.message}`, 'error');
            } finally {
                setButtonLoading('btn-import-data', false);
                fileInput.value = '';
            }
        }

        // Confirm delete all
        window.confirmDeleteAll = function() {
            if (confirm('‚ö†Ô∏è Are you sure you want to delete ALL location data from your Pod? This action cannot be undone!')) {
                deleteAllLocationData();
            }
        }

        // Delete all location data
        async function deleteAllLocationData() {
            log('Deleting all location data...', 'info');
            setButtonLoading('btn-delete-all', true);
            document.getElementById('delete-result').innerHTML = '';

            try {
                const webId = session.info.webId;
                const profileDataset = await solidClient.getSolidDataset(webId, { fetch: session.fetch });
                const profileThing = solidClient.getThing(profileDataset, webId);
                const storage = solidClient.getUrl(profileThing, 'http://www.w3.org/ns/pim/space#storage');

                if (!storage) {
                    throw new Error('No storage location found in profile');
                }

                const containerUrl = `${storage}private/location-tracker/`;

                // Try to get container contents
                let dataset;
                try {
                    dataset = await solidClient.getSolidDataset(containerUrl, { fetch: session.fetch });
                } catch (error) {
                    log('‚úó No location data found', 'warning');
                    showAlert('delete-result', 'No location data found to delete', 'warning');
                    return;
                }

                // Get all contained resources
                const resources = solidClient.getContainedResourceUrlAll(dataset);
                let deleted = 0;

                for (const resourceUrl of resources) {
                    if (resourceUrl.endsWith('.ttl')) {
                        try {
                            await solidClient.deleteFile(resourceUrl, { fetch: session.fetch });
                            deleted++;
                            log(`‚úì Deleted ${resourceUrl}`, 'success');
                        } catch (error) {
                            log(`‚ö† Failed to delete ${resourceUrl}: ${error.message}`, 'warning');
                        }
                    }
                }

                log(`‚úì Deleted ${deleted} location file(s)`, 'success');
                showAlert('delete-result', `Successfully deleted ${deleted} location file(s)`, 'success');

            } catch (error) {
                log(`‚úó Delete failed: ${error.message}`, 'error');
                showAlert('delete-result', `Delete failed: ${error.message}`, 'error');
            } finally {
                setButtonLoading('btn-delete-all', false);
            }
        }

        // ========================================
        // PERMISSIONS & ACCESS CONTROL FUNCTIONS
        // ========================================

        // Get location-tracker container URL
        async function getLocationContainerUrl() {
            const webId = session.info.webId;
            const profileDataset = await solidClient.getSolidDataset(webId, { fetch: session.fetch });
            const profileThing = solidClient.getThing(profileDataset, webId);
            const storage = solidClient.getUrl(profileThing, 'http://www.w3.org/ns/pim/space#storage');

            if (!storage) {
                throw new Error('No storage location found in profile');
            }

            return `${storage}private/location-tracker/`;
        }

        // Refresh access information display
        window.refreshAccessInfo = async function() {
            if (!session || !session.info.isLoggedIn) {
                showAlert('grant-result', 'Please log in first', 'warning');
                return;
            }

            log('Refreshing access information...', 'info');
            setButtonLoading('btn-refresh-access', true);

            try {
                const containerUrl = await getLocationContainerUrl();

                // Get public access (may return null if no ACL exists yet)
                let publicAccess = null;
                try {
                    publicAccess = await solidClient.universalAccess.getPublicAccess(
                        containerUrl,
                        { fetch: session.fetch }
                    );
                } catch (error) {
                    // Silently handle 404s for missing ACL files - this is normal
                    if (!error.message.includes('404') && !error.message.includes('Not Found')) {
                        throw error; // Re-throw non-404 errors
                    }
                    console.log('[Access Control] No ACL file found - using defaults');
                }

                // Get all agent access (may return empty if no ACL exists yet)
                let agentAccessAll = {};
                try {
                    agentAccessAll = await solidClient.universalAccess.getAgentAccessAll(
                        containerUrl,
                        { fetch: session.fetch }
                    );
                } catch (error) {
                    // Silently handle 404s for missing ACL files - this is normal
                    if (!error.message.includes('404') && !error.message.includes('Not Found')) {
                        throw error; // Re-throw non-404 errors
                    }
                    console.log('[Access Control] No ACL file found - using defaults');
                }

                // Display public access
                let publicStatus = 'üîí Private';
                if (publicAccess) {
                    if (publicAccess.read && publicAccess.write) {
                        publicStatus = 'üåê Public (Read-Write)';
                    } else if (publicAccess.read) {
                        publicStatus = 'üëÅÔ∏è Public (Read-Only)';
                    }
                }

                document.getElementById('settings-privacy-info').innerHTML = `
                    <p><strong>Public Access:</strong> ${publicStatus}</p>
                    <p style="margin-top: 10px; font-size: 13px;">
                        Container: <code>${containerUrl}</code>
                    </p>
                    ${!publicAccess && Object.keys(agentAccessAll || {}).length === 0 ?
                        '<p style="margin-top: 10px; font-size: 12px; color: #888;"><em>No ACL file exists yet. Permissions will be created when you first grant access.</em></p>' : ''}
                `;

                // Display agent permissions
                await displayCurrentPermissions(agentAccessAll);

                log('‚úì Access information refreshed', 'success');
            } catch (error) {
                log(`‚úó Failed to load access info: ${error.message}`, 'error');
                document.getElementById('settings-privacy-info').innerHTML = `
                    <p style="color: #f44336;">Failed to load access information: ${error.message}</p>
                `;
            } finally {
                setButtonLoading('btn-refresh-access', false);
            }
        }

        // Display current permissions list
        async function displayCurrentPermissions(agentAccessAll) {
            const permissionsDiv = document.getElementById('current-permissions-list');

            if (!agentAccessAll || Object.keys(agentAccessAll).length === 0) {
                permissionsDiv.innerHTML = '<p style="color: #666;">No individual permissions granted yet.</p>';
                return;
            }

            let html = '<ul style="list-style: none; padding: 0; margin: 0;">';
            for (const [agent, access] of Object.entries(agentAccessAll)) {
                const permissions = [];
                if (access.read) permissions.push('Read');
                if (access.append) permissions.push('Append');
                if (access.write) permissions.push('Write');

                const permStr = permissions.length > 0 ? permissions.join(', ') : 'None';

                html += `
                    <li style="padding: 10px; margin-bottom: 10px; background: #f9f9f9; border-radius: 8px; border-left: 4px solid #667eea;">
                        <div style="font-weight: 600; color: #333; margin-bottom: 5px; word-break: break-all;">
                            ${agent}
                        </div>
                        <div style="font-size: 13px; color: #666;">
                            Permissions: <strong>${permStr}</strong>
                        </div>
                    </li>
                `;
            }
            html += '</ul>';

            permissionsDiv.innerHTML = html;
        }

        // Set public access
        window.setPublicAccess = async function(accessType) {
            if (!session || !session.info.isLoggedIn) {
                showAlert('grant-result', 'Please log in first', 'warning');
                return;
            }

            const accessMap = {
                'read': { read: true, write: false },
                'write': { read: true, write: true },
                'none': { read: false, write: false }
            };

            const access = accessMap[accessType];
            const actionName = accessType === 'none' ? 'Making private' : `Making public (${accessType})`;

            log(`${actionName}...`, 'info');
            document.getElementById('grant-result').innerHTML = '';

            try {
                const containerUrl = await getLocationContainerUrl();

                const newAccess = await solidClient.universalAccess.setPublicAccess(
                    containerUrl,
                    access,
                    { fetch: session.fetch }
                );

                if (newAccess === null) {
                    throw new Error('Failed to update public access');
                }

                log(`‚úì Public access updated`, 'success');
                showAlert('grant-result', `Successfully updated public access`, 'success');

                // Refresh access info
                await refreshAccessInfo();
            } catch (error) {
                log(`‚úó Failed to update public access: ${error.message}`, 'error');
                showAlert('grant-result', `Failed: ${error.message}`, 'error');
            }
        }

        // Grant access to specific agent
        window.grantAgentAccess = async function(accessType) {
            if (!session || !session.info.isLoggedIn) {
                showAlert('grant-result', 'Please log in first', 'warning');
                return;
            }

            const webIdInput = document.getElementById('input-grant-webid');
            const targetWebId = webIdInput.value.trim();

            if (!targetWebId) {
                showAlert('grant-result', 'Please enter a WebID', 'warning');
                return;
            }

            if (!targetWebId.startsWith('http://') && !targetWebId.startsWith('https://')) {
                showAlert('grant-result', 'WebID must be a valid URL (starting with http:// or https://)', 'warning');
                return;
            }

            const access = accessType === 'read'
                ? { read: true, write: false }
                : { read: true, write: true };

            log(`Granting ${accessType} access to ${targetWebId}...`, 'info');
            setButtonLoading(`btn-grant-${accessType}`, true);
            document.getElementById('grant-result').innerHTML = '';

            try {
                const containerUrl = await getLocationContainerUrl();

                // Grant access to the container
                const newAccess = await solidClient.universalAccess.setAgentAccess(
                    containerUrl,
                    targetWebId,
                    access,
                    { fetch: session.fetch }
                );

                if (newAccess === null) {
                    throw new Error('Failed to grant access to container');
                }

                log(`‚úì Container access granted, now granting access to existing files...`, 'info');

                // Also grant access to all existing files in the container
                try {
                    const containerDataset = await solidClient.getSolidDataset(containerUrl, { fetch: session.fetch });
                    const resources = solidClient.getContainedResourceUrlAll(containerDataset);

                    let filesGranted = 0;
                    for (const resourceUrl of resources) {
                        if (resourceUrl.endsWith('.ttl')) {
                            try {
                                await solidClient.universalAccess.setAgentAccess(
                                    resourceUrl,
                                    targetWebId,
                                    access,
                                    { fetch: session.fetch }
                                );
                                filesGranted++;
                            } catch (fileError) {
                                console.warn(`Failed to grant access to ${resourceUrl}:`, fileError);
                            }
                        }
                    }
                    log(`‚úì Access granted to ${filesGranted} existing location files`, 'success');
                } catch (filesError) {
                    console.warn('Failed to grant access to existing files:', filesError);
                }

                log(`‚úì Access granted to ${targetWebId}`, 'success');
                showAlert('grant-result', `Successfully granted ${accessType} access to ${targetWebId} for container and all existing files`, 'success');

                // Clear input and refresh
                webIdInput.value = '';
                await refreshAccessInfo();
            } catch (error) {
                log(`‚úó Failed to grant access: ${error.message}`, 'error');
                showAlert('grant-result', `Failed: ${error.message}`, 'error');
            } finally {
                setButtonLoading(`btn-grant-${accessType}`, false);
            }
        }

        // Revoke access from specific agent
        window.revokeAgentAccess = async function() {
            if (!session || !session.info.isLoggedIn) {
                showAlert('revoke-result', 'Please log in first', 'warning');
                return;
            }

            const webIdInput = document.getElementById('input-revoke-webid');
            const targetWebId = webIdInput.value.trim();

            if (!targetWebId) {
                showAlert('revoke-result', 'Please enter a WebID', 'warning');
                return;
            }

            log(`Revoking access from ${targetWebId}...`, 'info');
            setButtonLoading('btn-revoke-access', true);
            document.getElementById('revoke-result').innerHTML = '';

            try {
                const containerUrl = await getLocationContainerUrl();

                const newAccess = await solidClient.universalAccess.setAgentAccess(
                    containerUrl,
                    targetWebId,
                    { read: false, write: false },
                    { fetch: session.fetch }
                );

                if (newAccess === null) {
                    throw new Error('Failed to revoke access');
                }

                log(`‚úì Access revoked from ${targetWebId}`, 'success');
                showAlert('revoke-result', `Successfully revoked access from ${targetWebId}`, 'success');

                // Clear input and refresh
                webIdInput.value = '';
                await refreshAccessInfo();
            } catch (error) {
                log(`‚úó Failed to revoke access: ${error.message}`, 'error');
                showAlert('revoke-result', `Failed: ${error.message}`, 'error');
            } finally {
                setButtonLoading('btn-revoke-access', false);
            }
        }

        // Generate share link
        window.generateShareLink = async function() {
            if (!session || !session.info.isLoggedIn) {
                showAlert('share-link-result', 'Please log in first', 'warning');
                return;
            }

            log('Generating share link...', 'info');
            document.getElementById('share-link-result').innerHTML = '';

            try {
                const containerUrl = await getLocationContainerUrl();

                const linkHtml = `
                    <div style="margin-top: 15px; padding: 15px; background: #f0f7ff; border-radius: 8px; border: 2px solid #667eea;">
                        <p style="margin-bottom: 10px; font-weight: 600; color: #333;">Share this link:</p>
                        <input type="text" value="${containerUrl}" readonly
                            style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px; font-family: monospace; font-size: 13px;"
                            onclick="this.select()">
                        <p style="margin-top: 10px; font-size: 13px; color: #666;">
                            ‚ö†Ô∏è Note: Recipients will need appropriate permissions to access this container.
                            Grant them access using the "Grant Access to Others" section above.
                        </p>
                        <button onclick="copyShareLink('${containerUrl}')" class="secondary" style="margin-top: 10px;">
                            üìã Copy Link
                        </button>
                    </div>
                `;

                document.getElementById('share-link-result').innerHTML = linkHtml;
                log('‚úì Share link generated', 'success');
            } catch (error) {
                log(`‚úó Failed to generate share link: ${error.message}`, 'error');
                showAlert('share-link-result', `Failed: ${error.message}`, 'error');
            }
        }

        // Copy share link to clipboard
        window.copyShareLink = async function(url) {
            try {
                await navigator.clipboard.writeText(url);
                showAlert('share-link-result', 'Link copied to clipboard!', 'success');
                log('‚úì Link copied to clipboard', 'success');
            } catch (error) {
                showAlert('share-link-result', 'Failed to copy link', 'error');
            }
        }

        // ========================================
        // END PERMISSIONS & ACCESS CONTROL
        // ========================================

        // ========================================
        // SOCIAL FEATURES (FOAF & FRIENDS)
        // ========================================

        // Get friends list container URL
        async function getFriendsListUrl() {
            const webId = session.info.webId;
            console.log('[getFriendsListUrl] Fetching own WebID:', webId);

            try {
                const webIdDataset = await solidClient.getSolidDataset(webId, { fetch: session.fetch });
                console.log('[getFriendsListUrl] Successfully fetched own WebID dataset');

                let profileThing = solidClient.getThing(webIdDataset, webId);
                console.log('[getFriendsListUrl] WebID thing:', profileThing);

                // Check if this WebID points to a separate profile document
                let profileDocUrl = null;
                if (profileThing) {
                    profileDocUrl = solidClient.getUrl(profileThing, 'http://www.w3.org/2000/01/rdf-schema#seeAlso') ||
                                   solidClient.getUrl(profileThing, 'http://xmlns.com/foaf/0.1/isPrimaryTopicOf');
                    console.log('[getFriendsListUrl] Profile document URL from WebID:', profileDocUrl);
                }

                // If not found at exact WebID, try to get all things
                if (!profileThing) {
                    const allThings = solidClient.getThingAll(webIdDataset);
                    console.log('[getFriendsListUrl] All things in WebID dataset:', allThings.length);
                    if (allThings.length > 0) {
                        profileThing = allThings[0];
                        profileDocUrl = profileDocUrl ||
                                       solidClient.getUrl(profileThing, 'http://www.w3.org/2000/01/rdf-schema#seeAlso') ||
                                       solidClient.getUrl(profileThing, 'http://xmlns.com/foaf/0.1/isPrimaryTopicOf');
                    }
                }

                // If we found a separate profile document, fetch it
                let actualProfileThing = profileThing;
                if (profileDocUrl && profileDocUrl !== webId) {
                    console.log('[getFriendsListUrl] Fetching separate profile document:', profileDocUrl);
                    try {
                        const profileDataset = await solidClient.getSolidDataset(profileDocUrl, { fetch: session.fetch });
                        console.log('[getFriendsListUrl] Profile document fetched successfully');

                        actualProfileThing = solidClient.getThing(profileDataset, webId);

                        if (!actualProfileThing) {
                            const profileThings = solidClient.getThingAll(profileDataset);
                            console.log('[getFriendsListUrl] All things in profile document:', profileThings.length);
                            if (profileThings.length > 0) {
                                actualProfileThing = profileThings[0];
                            }
                        }
                    } catch (profileError) {
                        console.warn('[getFriendsListUrl] Failed to fetch profile document, using WebID thing:', profileError);
                    }
                }

                if (!actualProfileThing) {
                    throw new Error('Could not find profile thing in WebID document or linked profile');
                }

                const storage = solidClient.getUrl(actualProfileThing, 'http://www.w3.org/ns/pim/space#storage');
                console.log('[getFriendsListUrl] Storage URL:', storage);

                if (!storage) {
                    throw new Error('No storage location found in profile');
                }

                return `${storage}private/friends.ttl`;
            } catch (error) {
                console.error('[getFriendsListUrl] Error:', error);
                throw error;
            }
        }

        // Load friends list from Pod
        async function loadFriendsList() {
            try {
                const friendsUrl = await getFriendsListUrl();

                let friendsDataset;
                try {
                    friendsDataset = await solidClient.getSolidDataset(friendsUrl, { fetch: session.fetch });
                } catch (error) {
                    // If friends list doesn't exist, return empty array
                    if (error.message.includes('404') || error.message.includes('Not Found')) {
                        console.log('[Social] No friends list found - will create on first add');
                        return [];
                    }
                    throw error;
                }

                // Get the main thing (user's profile in friends file)
                const userThing = solidClient.getThing(friendsDataset, `${friendsUrl}#me`);
                if (!userThing) {
                    return [];
                }

                // Get all foaf:knows relationships
                const friendWebIds = solidClient.getUrlAll(userThing, 'http://xmlns.com/foaf/0.1/knows');

                return friendWebIds;
            } catch (error) {
                console.error('[Social] Failed to load friends list:', error);
                throw error;
            }
        }

        // Display friends list in UI
        async function displayFriendsList() {
            const friendsDiv = document.getElementById('friends-list');

            try {
                const friends = await loadFriendsList();

                if (friends.length === 0) {
                    friendsDiv.innerHTML = '<p style="color: #666;">No friends added yet. Add friends to see their shared locations!</p>';
                    return;
                }

                // Fetch profile info for each friend
                let html = '<ul style="list-style: none; padding: 0; margin: 0;">';

                for (const friendWebId of friends) {
                    let friendName = 'Loading...';

                    try {
                        const profile = await fetchFriendProfile(friendWebId);
                        friendName = profile.name || friendWebId.split('/').pop();
                    } catch (error) {
                        friendName = friendWebId.split('/').pop();
                        console.warn(`Failed to fetch profile for ${friendWebId}:`, error);
                    }

                    html += `
                        <li style="padding: 12px; margin-bottom: 10px; background: #f9f9f9; border-radius: 8px; border-left: 4px solid #667eea; display: flex; justify-content: space-between; align-items: center;">
                            <div style="flex: 1; min-width: 0;">
                                <div style="font-weight: 600; color: #333; margin-bottom: 5px;">
                                    ${friendName}
                                </div>
                                <div style="font-size: 12px; color: #666; word-break: break-all;">
                                    ${friendWebId}
                                </div>
                            </div>
                            <button onclick="removeFriend('${friendWebId}')" class="secondary" style="margin-left: 10px; padding: 5px 10px; font-size: 12px;">
                                ‚ùå Remove
                            </button>
                        </li>
                    `;
                }

                html += '</ul>';
                friendsDiv.innerHTML = html;

            } catch (error) {
                friendsDiv.innerHTML = `<p style="color: #f44336;">Failed to load friends: ${error.message}</p>`;
            }
        }

        // Fetch friend's profile information
        async function fetchFriendProfile(webId) {
            try {
                console.log('[fetchFriendProfile] Fetching profile:', webId);

                // Try unauthenticated fetch first (WebIDs should be publicly readable)
                let webIdDataset;
                try {
                    console.log('[fetchFriendProfile] Attempting unauthenticated fetch...');
                    webIdDataset = await solidClient.getSolidDataset(webId);
                    console.log('[fetchFriendProfile] Unauthenticated fetch successful');
                } catch (unauthError) {
                    console.log('[fetchFriendProfile] Unauthenticated fetch failed, trying with authentication:', unauthError.message);
                    // Fall back to authenticated fetch
                    webIdDataset = await solidClient.getSolidDataset(webId, { fetch: session.fetch });
                    console.log('[fetchFriendProfile] Authenticated fetch successful');
                }

                console.log('[fetchFriendProfile] WebID dataset fetched successfully');

                // Get the thing at the WebID
                let profileThing = solidClient.getThing(webIdDataset, webId);
                console.log('[fetchFriendProfile] WebID thing:', profileThing);

                // Check if this WebID points to a separate profile document
                let profileDocUrl = null;
                if (profileThing) {
                    // Look for rdfs:seeAlso or foaf:isPrimaryTopicOf which often point to the profile document
                    profileDocUrl = solidClient.getUrl(profileThing, 'http://www.w3.org/2000/01/rdf-schema#seeAlso') ||
                                   solidClient.getUrl(profileThing, 'http://xmlns.com/foaf/0.1/isPrimaryTopicOf');
                    console.log('[fetchFriendProfile] Profile document URL from WebID:', profileDocUrl);
                }

                // If no profileThing, try to find any thing in the dataset
                if (!profileThing) {
                    console.warn('[fetchFriendProfile] No thing found at WebID, trying to find any thing in dataset');
                    const allThings = solidClient.getThingAll(webIdDataset);
                    console.log('[fetchFriendProfile] All things in WebID dataset:', allThings.length);

                    if (allThings.length > 0) {
                        profileThing = allThings[0];
                        // Also check for profile document link from this thing
                        profileDocUrl = profileDocUrl ||
                                       solidClient.getUrl(profileThing, 'http://www.w3.org/2000/01/rdf-schema#seeAlso') ||
                                       solidClient.getUrl(profileThing, 'http://xmlns.com/foaf/0.1/isPrimaryTopicOf');
                    }
                }

                // If we found a separate profile document, fetch it
                let actualProfileThing = profileThing;
                if (profileDocUrl && profileDocUrl !== webId) {
                    console.log('[fetchFriendProfile] Fetching separate profile document:', profileDocUrl);
                    try {
                        // Try unauthenticated fetch first for profile document too
                        let profileDataset;
                        try {
                            console.log('[fetchFriendProfile] Attempting unauthenticated fetch for profile document...');
                            profileDataset = await solidClient.getSolidDataset(profileDocUrl);
                            console.log('[fetchFriendProfile] Profile document unauthenticated fetch successful');
                        } catch (profileUnauthError) {
                            console.log('[fetchFriendProfile] Profile document unauthenticated fetch failed, trying with authentication');
                            profileDataset = await solidClient.getSolidDataset(profileDocUrl, { fetch: session.fetch });
                            console.log('[fetchFriendProfile] Profile document authenticated fetch successful');
                        }
                        console.log('[fetchFriendProfile] Profile document fetched successfully');

                        // Try to find the thing that represents the WebID in the profile document
                        actualProfileThing = solidClient.getThing(profileDataset, webId);

                        if (!actualProfileThing) {
                            // If not found, try to get all things and use the first one
                            const profileThings = solidClient.getThingAll(profileDataset);
                            console.log('[fetchFriendProfile] All things in profile document:', profileThings.length);
                            if (profileThings.length > 0) {
                                actualProfileThing = profileThings[0];
                            }
                        }
                    } catch (profileError) {
                        console.warn('[fetchFriendProfile] Failed to fetch profile document, using WebID thing:', profileError);
                    }
                }

                if (!actualProfileThing) {
                    throw new Error('No profile data found at WebID or linked profile document');
                }

                // Try multiple name predicates
                const name = solidClient.getStringNoLocale(actualProfileThing, 'http://xmlns.com/foaf/0.1/name') ||
                            solidClient.getStringNoLocale(actualProfileThing, 'http://www.w3.org/2006/vcard/ns#fn') ||
                            solidClient.getStringNoLocale(actualProfileThing, 'http://schema.org/name');

                const storage = solidClient.getUrl(actualProfileThing, 'http://www.w3.org/ns/pim/space#storage');

                console.log('[fetchFriendProfile] Final result - name:', name, 'storage:', storage);
                return {
                    webId,
                    name,
                    storage
                };
            } catch (error) {
                console.error(`[fetchFriendProfile] Failed to fetch profile for ${webId}:`, error);
                // Re-throw the error so the UI can show it to the user
                throw new Error(`Unable to fetch profile: ${error.message}`);
            }
        }

        // Add friend to friends list
        window.addFriend = async function() {
            if (!session || !session.info.isLoggedIn) {
                showAlert('add-friend-result', 'Please log in first', 'warning');
                return;
            }

            const webIdInput = document.getElementById('input-friend-webid');
            const friendWebId = webIdInput.value.trim();

            if (!friendWebId) {
                showAlert('add-friend-result', 'Please enter a WebID', 'warning');
                return;
            }

            if (!friendWebId.startsWith('http://') && !friendWebId.startsWith('https://')) {
                showAlert('add-friend-result', 'WebID must be a valid URL', 'warning');
                return;
            }

            log(`Adding friend: ${friendWebId}...`, 'info');
            setButtonLoading('btn-add-friend', true);
            document.getElementById('add-friend-result').innerHTML = '';

            try {
                const friendsUrl = await getFriendsListUrl();

                // Load or create friends dataset
                let friendsDataset;
                try {
                    friendsDataset = await solidClient.getSolidDataset(friendsUrl, { fetch: session.fetch });
                } catch (error) {
                    // Create new dataset if it doesn't exist
                    if (error.message.includes('404') || error.message.includes('Not Found')) {
                        friendsDataset = solidClient.createSolidDataset();
                    } else {
                        throw error;
                    }
                }

                // Get or create the user thing
                let userThing = solidClient.getThing(friendsDataset, `${friendsUrl}#me`);
                if (!userThing) {
                    userThing = solidClient.createThing({ url: `${friendsUrl}#me` });
                    userThing = solidClient.addUrl(userThing, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type', 'http://xmlns.com/foaf/0.1/Person');
                }

                // Check if already friends
                const existingFriends = solidClient.getUrlAll(userThing, 'http://xmlns.com/foaf/0.1/knows');
                if (existingFriends.includes(friendWebId)) {
                    showAlert('add-friend-result', 'This person is already in your friends list', 'info');
                    log('Friend already exists in list', 'info');
                    setButtonLoading('btn-add-friend', false);
                    return;
                }

                // Add friend relationship
                userThing = solidClient.addUrl(userThing, 'http://xmlns.com/foaf/0.1/knows', friendWebId);
                friendsDataset = solidClient.setThing(friendsDataset, userThing);

                // Save to Pod
                await solidClient.saveSolidDatasetAt(friendsUrl, friendsDataset, { fetch: session.fetch });

                log(`‚úì Friend added: ${friendWebId}`, 'success');
                showAlert('add-friend-result', `Successfully added friend!`, 'success');

                // Clear input and refresh display
                webIdInput.value = '';
                await displayFriendsList();
                await refreshSocialFeed();

            } catch (error) {
                log(`‚úó Failed to add friend: ${error.message}`, 'error');
                showAlert('add-friend-result', `Failed: ${error.message}`, 'error');
            } finally {
                setButtonLoading('btn-add-friend', false);
            }
        }

        // Remove friend from friends list
        window.removeFriend = async function(friendWebId) {
            if (!confirm(`Remove ${friendWebId} from your friends list?`)) {
                return;
            }

            log(`Removing friend: ${friendWebId}...`, 'info');

            try {
                const friendsUrl = await getFriendsListUrl();
                let friendsDataset = await solidClient.getSolidDataset(friendsUrl, { fetch: session.fetch });

                let userThing = solidClient.getThing(friendsDataset, `${friendsUrl}#me`);
                if (!userThing) {
                    throw new Error('Friends list not found');
                }

                // Remove friend relationship
                userThing = solidClient.removeUrl(userThing, 'http://xmlns.com/foaf/0.1/knows', friendWebId);
                friendsDataset = solidClient.setThing(friendsDataset, userThing);

                // Save to Pod
                await solidClient.saveSolidDatasetAt(friendsUrl, friendsDataset, { fetch: session.fetch });

                log(`‚úì Friend removed: ${friendWebId}`, 'success');
                showAlert('add-friend-result', `Friend removed successfully`, 'success');

                // Refresh display
                await displayFriendsList();
                await refreshSocialFeed();

            } catch (error) {
                log(`‚úó Failed to remove friend: ${error.message}`, 'error');
                showAlert('add-friend-result', `Failed to remove: ${error.message}`, 'error');
            }
        }

        // Discover friend profile
        window.discoverFriend = async function() {
            if (!session || !session.info.isLoggedIn) {
                showAlert('discover-result', 'Please log in first', 'warning');
                return;
            }

            const webIdInput = document.getElementById('input-discover-webid');
            const targetWebId = webIdInput.value.trim();

            if (!targetWebId) {
                showAlert('discover-result', 'Please enter a WebID', 'warning');
                return;
            }

            log(`Discovering profile: ${targetWebId}...`, 'info');
            setButtonLoading('btn-discover-friend', true);
            document.getElementById('discover-result').innerHTML = '';

            try {
                const profile = await fetchFriendProfile(targetWebId);

                const profileHtml = `
                    <div style="margin-top: 15px; padding: 15px; background: #f9f9f9; border-radius: 8px;">
                        <h4 style="margin-bottom: 10px; color: #667eea;">${profile.name || 'Unknown Name'}</h4>
                        <p style="font-size: 13px; color: #666; margin-bottom: 5px;">
                            <strong>WebID:</strong> <span style="word-break: break-all;">${profile.webId}</span>
                        </p>
                        ${profile.storage ? `
                            <p style="font-size: 13px; color: #666; margin-bottom: 10px;">
                                <strong>Storage:</strong> <span style="word-break: break-all;">${profile.storage}</span>
                            </p>
                        ` : ''}
                        <p style="font-size: 12px; color: #888; margin-top: 10px;">
                            You can add this person to your friends list to see their shared location data.
                        </p>
                    </div>
                `;

                document.getElementById('discover-result').innerHTML = profileHtml;
                log(`‚úì Profile discovered`, 'success');

            } catch (error) {
                log(`‚úó Failed to discover profile: ${error.message}`, 'error');
                showAlert('discover-result', `Failed: ${error.message}`, 'error');
            } finally {
                setButtonLoading('btn-discover-friend', false);
            }
        }

        // Refresh social feed
        window.refreshSocialFeed = async function() {
            if (!session || !session.info.isLoggedIn) {
                return;
            }

            log('Refreshing social feed...', 'info');
            setButtonLoading('btn-refresh-feed', true);

            try {
                const friends = await loadFriendsList();

                if (friends.length === 0) {
                    document.getElementById('social-feed').innerHTML = '<p style="color: #666;">No friends added yet. Add friends to see their shared locations!</p>';
                    setButtonLoading('btn-refresh-feed', false);
                    return;
                }

                let allLocations = [];
                let accessErrors = [];

                // Fetch locations from each friend's Pod
                for (const friendWebId of friends) {
                    try {
                        const profile = await fetchFriendProfile(friendWebId);

                        if (!profile.storage) {
                            console.warn(`[SocialFeed] No storage found for ${friendWebId}`);
                            accessErrors.push(`${friendWebId}: No storage location found in profile`);
                            continue;
                        }

                        const locationContainerUrl = `${profile.storage}private/location-tracker/`;
                        console.log(`[SocialFeed] Attempting to fetch locations from ${locationContainerUrl}`);

                        // Try to fetch friend's locations
                        try {
                            const locationDataset = await solidClient.getSolidDataset(locationContainerUrl, { fetch: session.fetch });
                            const resources = solidClient.getContainedResourceUrlAll(locationDataset);
                            console.log(`[SocialFeed] Found ${resources.length} resources in ${friendWebId}'s location container`);
                            console.log(`[SocialFeed] Resource URLs:`, resources);

                            let locationCount = 0;
                            for (const resourceUrl of resources) {
                                console.log(`[SocialFeed] Checking resource: ${resourceUrl}`);
                                if (resourceUrl.endsWith('.ttl')) {
                                    console.log(`[SocialFeed] Resource is a .ttl file, attempting to fetch...`);
                                    try {
                                        const locationFile = await solidClient.getSolidDataset(resourceUrl, { fetch: session.fetch });
                                        console.log(`[SocialFeed] Successfully fetched ${resourceUrl}`);

                                        // Try to get the location thing
                                        let locationThing = solidClient.getThing(locationFile, `${resourceUrl}#location`);
                                        console.log(`[SocialFeed] Location thing with #location:`, locationThing);

                                        // If not found, try to get all things and use the first one
                                        if (!locationThing) {
                                            const allThings = solidClient.getThingAll(locationFile);
                                            console.log(`[SocialFeed] All things in file:`, allThings.length, allThings);
                                            if (allThings.length > 0) {
                                                locationThing = allThings[0];
                                                console.log(`[SocialFeed] Using first thing:`, locationThing);
                                            }
                                        }

                                        if (locationThing) {
                                            const lat = solidClient.getDecimal(locationThing, 'http://www.w3.org/2003/01/geo/wgs84_pos#lat');
                                            const long = solidClient.getDecimal(locationThing, 'http://www.w3.org/2003/01/geo/wgs84_pos#long');
                                            const created = solidClient.getDatetime(locationThing, 'http://purl.org/dc/terms/created');
                                            const name = solidClient.getStringNoLocale(locationThing, 'http://schema.org/name');

                                            allLocations.push({
                                                friendWebId,
                                                friendName: profile.name || friendWebId.split('/').pop(),
                                                lat,
                                                long,
                                                created: created ? new Date(created) : new Date(),
                                                name: name || 'Location',
                                                url: resourceUrl
                                            });
                                            locationCount++;
                                        }
                                    } catch (locationError) {
                                        // Skip locations we can't access
                                        console.log(`[SocialFeed] Cannot access ${resourceUrl}:`, locationError.message);
                                    }
                                }
                            }
                            console.log(`[SocialFeed] Successfully loaded ${locationCount} locations from ${friendWebId}`);
                        } catch (containerError) {
                            // Friend might not have location-tracker container or it's not shared
                            console.log(`[SocialFeed] Cannot access location container for ${friendWebId}:`, containerError.message);

                            if (containerError.message.includes('401') || containerError.message.includes('403')) {
                                accessErrors.push(`${profile.name || friendWebId}: Access denied. They need to grant you read access to their location container.`);
                            } else if (containerError.message.includes('404')) {
                                accessErrors.push(`${profile.name || friendWebId}: No location data found (container doesn't exist).`);
                            } else {
                                accessErrors.push(`${profile.name || friendWebId}: ${containerError.message}`);
                            }
                        }
                    } catch (profileError) {
                        console.warn(`[SocialFeed] Failed to fetch locations for ${friendWebId}:`, profileError);
                        accessErrors.push(`${friendWebId}: Failed to fetch profile`);
                    }
                }

                // Sort by date (newest first)
                allLocations.sort((a, b) => b.created - a.created);

                if (allLocations.length === 0) {
                    let errorDetails = '';
                    if (accessErrors.length > 0) {
                        errorDetails = `
                            <div style="margin-top: 15px; padding: 12px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">
                                <p style="font-weight: 600; margin-bottom: 8px; color: #856404;">Access Issues:</p>
                                <ul style="margin: 0; padding-left: 20px; color: #856404; font-size: 13px;">
                                    ${accessErrors.map(err => `<li style="margin-bottom: 4px;">${err}</li>`).join('')}
                                </ul>
                                <p style="margin-top: 10px; font-size: 13px; color: #856404;">
                                    <strong>How to fix:</strong> Your friends need to go to their Privacy tab and grant you (${session.info.webId}) read access to their location container.
                                </p>
                            </div>
                        `;
                    }

                    document.getElementById('social-feed').innerHTML = `
                        <p style="color: #666;">
                            No shared locations found. Your friends may not have shared their location data yet,
                            or you may need them to grant you read access to their location container.
                        </p>
                        ${errorDetails}
                    `;
                } else {
                    let feedHtml = '<div style="max-height: 400px; overflow-y: auto;">';

                    for (const location of allLocations) {
                        const timeAgo = getTimeAgo(location.created);

                        feedHtml += `
                            <div style="padding: 12px; margin-bottom: 10px; background: #f9f9f9; border-radius: 8px; border-left: 4px solid #667eea;">
                                <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                                    <div>
                                        <div style="font-weight: 600; color: #333;">
                                            üìç ${location.name}
                                        </div>
                                        <div style="font-size: 12px; color: #667eea; margin-top: 2px;">
                                            ${location.friendName}
                                        </div>
                                    </div>
                                    <div style="font-size: 11px; color: #888; text-align: right;">
                                        ${timeAgo}
                                    </div>
                                </div>
                                <div style="font-size: 12px; color: #666;">
                                    Coordinates: ${location.lat}, ${location.long}
                                </div>
                            </div>
                        `;
                    }

                    feedHtml += '</div>';
                    feedHtml += `<p style="margin-top: 10px; font-size: 12px; color: #888;">Found ${allLocations.length} shared location(s) from ${friends.length} friend(s)</p>`;

                    document.getElementById('social-feed').innerHTML = feedHtml;
                }

                log(`‚úì Social feed refreshed - ${allLocations.length} locations found`, 'success');

            } catch (error) {
                log(`‚úó Failed to refresh feed: ${error.message}`, 'error');
                document.getElementById('social-feed').innerHTML = `<p style="color: #f44336;">Failed to load feed: ${error.message}</p>`;
            } finally {
                setButtonLoading('btn-refresh-feed', false);
            }
        }

        // Helper function to get relative time
        function getTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffSecs = Math.floor(diffMs / 1000);
            const diffMins = Math.floor(diffSecs / 60);
            const diffHours = Math.floor(diffMins / 60);
            const diffDays = Math.floor(diffHours / 24);

            if (diffSecs < 60) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return date.toLocaleDateString();
        }

        // Initialize social features when settings are populated
        async function initializeSocialFeatures() {
            if (!session || !session.info.isLoggedIn) {
                return;
            }

            try {
                await displayFriendsList();
                await refreshSocialFeed();
            } catch (error) {
                console.error('[Social] Failed to initialize:', error);
            }
        }

        // ========================================
        // END SOCIAL FEATURES
        // ========================================

        // Refresh session
        window.refreshSession = async function() {
            log('Refreshing session...', 'info');
            setButtonLoading('btn-refresh-session', true);

            try {
                // Session refresh is handled automatically by the library
                // Just update the UI with current info
                updateSessionSettings();
                log('‚úì Session information refreshed', 'success');
            } catch (error) {
                log(`‚úó Failed to refresh session: ${error.message}`, 'error');
            } finally {
                setButtonLoading('btn-refresh-session', false);
            }
        }

        // ========================================
        // END SETTINGS UI FUNCTIONS
        // ========================================

        // ========================================
        // OFFLINE/SYNC FUNCTIONS
        // ========================================

        // Update online/offline status indicator
        function updateOnlineStatus() {
            isOnline = navigator.onLine;
            const dot = document.getElementById('offline-dot');
            const text = document.getElementById('offline-text');

            if (isOnline) {
                dot.className = 'connection-dot connected';
                text.textContent = 'Online';
                log('Connection restored - you are online', 'success');
            } else {
                dot.className = 'connection-dot error';
                text.textContent = 'Offline';
                log('Connection lost - working offline', 'warning');
            }
        }

        // Handle online/offline status changes
        async function handleOnlineStatusChange() {
            updateOnlineStatus();

            if (isOnline) {
                // Auto-sync when coming back online
                setTimeout(() => autoSync(), 1000);
            }
        }

        // Handle messages from Service Worker
        function handleServiceWorkerMessage(event) {
            const { data } = event;

            if (data.type === 'SYNC_TRIGGERED') {
                log('Background sync triggered by Service Worker', 'info');
                autoSync();
            }
        }

        // Update sync statistics display
        async function updateSyncStats() {
            try {
                const stats = await offlineStorage.getSyncStats();

                // Format last sync time more nicely
                let lastSyncDisplay = stats.lastSync;
                if (stats.lastSync !== 'Never') {
                    try {
                        const syncDate = new Date(stats.lastSync);
                        const now = new Date();
                        const diffMs = now - syncDate;
                        const diffSecs = Math.floor(diffMs / 1000);
                        const diffMins = Math.floor(diffSecs / 60);
                        const diffHours = Math.floor(diffMins / 60);
                        const diffDays = Math.floor(diffHours / 24);

                        if (diffSecs < 60) {
                            lastSyncDisplay = 'Just now';
                        } else if (diffMins < 60) {
                            lastSyncDisplay = `${diffMins} minute${diffMins !== 1 ? 's' : ''} ago`;
                        } else if (diffHours < 24) {
                            lastSyncDisplay = `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
                        } else if (diffDays < 7) {
                            lastSyncDisplay = `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;
                        } else {
                            lastSyncDisplay = syncDate.toLocaleString();
                        }
                    } catch (dateError) {
                        // If date parsing fails, use the raw value
                        console.warn('Failed to parse lastSync date:', dateError);
                    }
                }

                document.getElementById('sync-stats-content').innerHTML = `
                    <ul style="list-style: none; padding: 0; margin: 10px 0 0 0;">
                        <li>üìã Pending Operations: <strong>${stats.pendingOperations}</strong></li>
                        <li>‚ùå Failed Operations: <strong>${stats.failedOperations}</strong></li>
                        <li>üíæ Cached Locations: <strong>${stats.cachedLocations}</strong></li>
                        <li>‚úÖ Synced Locations: <strong>${stats.syncedLocations}</strong></li>
                        <li>‚è±Ô∏è Last Sync: <strong>${lastSyncDisplay}</strong></li>
                    </ul>
                `;

                // Update status indicator
                if (stats.failedOperations > 0) {
                    updateStatus('status-sync', 'error');
                } else if (stats.pendingOperations > 0) {
                    updateStatus('status-sync', 'loading');
                } else {
                    updateStatus('status-sync', 'success');
                }
            } catch (error) {
                console.error('Failed to update sync stats:', error);
            }
        }

        // Manual sync trigger
        window.manualSync = async function() {
            log('Manual sync triggered...', 'info');
            setButtonLoading('btn-sync', true);
            document.getElementById('sync-result').innerHTML = '';

            try {
                if (!isOnline) {
                    throw new Error('Cannot sync while offline');
                }

                if (!session || !session.info.isLoggedIn) {
                    throw new Error('Must be logged in to sync');
                }

                const result = await offlineStorage.syncPendingOperations(executeQueuedOperation);

                log(`‚úì Sync complete - ${result.succeeded} succeeded, ${result.failed} failed`, 'success');
                showAlert('sync-result', `Sync complete: ${result.succeeded} succeeded, ${result.failed} failed`, result.failed > 0 ? 'warning' : 'success');

                await updateSyncStats();
            } catch (error) {
                log(`‚úó Sync failed: ${error.message}`, 'error');
                showAlert('sync-result', `Sync failed: ${error.message}`, 'error');
            } finally {
                setButtonLoading('btn-sync', false);
            }
        }

        // Auto-sync (silent)
        async function autoSync() {
            try {
                if (!isOnline || !session || !session.info.isLoggedIn) {
                    return;
                }

                const stats = await offlineStorage.getSyncStats();
                if (stats.pendingOperations === 0) {
                    return;
                }

                log(`Auto-syncing ${stats.pendingOperations} pending operation(s)...`, 'info');

                const result = await offlineStorage.syncPendingOperations(executeQueuedOperation);

                if (result.succeeded > 0) {
                    log(`‚úì Auto-sync complete - ${result.succeeded} operations synced`, 'success');
                }

                await updateSyncStats();
            } catch (error) {
                console.error('Auto-sync failed:', error);
            }
        }

        // Execute a queued operation
        async function executeQueuedOperation(operation) {
            switch (operation.type) {
                case 'writeLocation':
                    return await writeLocationToPod(operation.data);
                default:
                    throw new Error(`Unknown operation type: ${operation.type}`);
            }
        }

        // Write location to Pod (extracted for reuse)
        async function writeLocationToPod(locationData) {
            const webId = session.info.webId;
            const profileDataset = await getSolidDataset(webId, { fetch: session.fetch });
            const profileThing = getThing(profileDataset, webId);
            const storage = getUrl(profileThing, 'http://www.w3.org/ns/pim/space#storage');

            if (!storage) {
                throw new Error('No storage location found in profile');
            }

            const containerUrl = `${storage}private/location-tracker/`;

            // Ensure container exists
            try {
                await createContainerAt(containerUrl, { fetch: session.fetch });
            } catch (error) {
                // Container might already exist
            }

            // Generate unique filename
            const timestamp = locationData.timestamp || Date.now();
            const locationFileName = `location-${timestamp}.ttl`;
            const locationUrl = `${containerUrl}${locationFileName}`;

            // Create Turtle data
            const turtleData = `@prefix schema: <http://schema.org/> .
@prefix geo: <http://www.w3.org/2003/01/geo/wgs84_pos#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix dcterms: <http://purl.org/dc/terms/> .

<#location> a schema:Place, geo:Point ;
    geo:lat "${locationData.latitude}"^^xsd:decimal ;
    geo:long "${locationData.longitude}"^^xsd:decimal ;
    schema:accuracy "${locationData.accuracy}"^^xsd:decimal ;
    dcterms:created "${new Date(timestamp).toISOString()}"^^xsd:dateTime ;
    schema:identifier "${locationData.deviceId}" .
`;

            // Write file to Pod
            await overwriteFile(
                locationUrl,
                new Blob([turtleData], { type: 'text/turtle' }),
                { fetch: session.fetch, contentType: 'text/turtle' }
            );

            return locationUrl;
        }

        // View sync queue
        window.viewSyncQueue = async function() {
            log('Loading sync queue...', 'info');

            try {
                const pendingOps = await offlineStorage.getPendingOperations();

                if (pendingOps.length === 0) {
                    showAlert('sync-result', 'No pending operations in queue', 'info');
                    return;
                }

                let queueHtml = '<div class="info-message"><ul style="list-style: none; padding: 0;">';

                pendingOps.forEach((op, index) => {
                    const date = new Date(op.timestamp).toLocaleString();
                    const retryInfo = op.retryCount > 0 ? ` (${op.retryCount} retries)` : '';

                    queueHtml += `
                        <li style="margin-bottom: 10px; padding: 10px; background: #f5f5f5; border-radius: 5px;">
                            <strong>#${index + 1}</strong> - ${op.type}${retryInfo}<br/>
                            <small>Queued: ${date}</small>
                            ${op.error ? `<br/><small style="color: #d32f2f;">Error: ${op.error}</small>` : ''}
                        </li>
                    `;
                });

                queueHtml += '</ul></div>';

                document.getElementById('sync-result').innerHTML = queueHtml;
                log(`Showing ${pendingOps.length} pending operation(s)`, 'info');
            } catch (error) {
                log(`‚úó Failed to load queue: ${error.message}`, 'error');
                showAlert('sync-result', `Failed to load queue: ${error.message}`, 'error');
            }
        }

        // Clear offline cache
        window.clearOfflineCache = async function() {
            if (!confirm('‚ö†Ô∏è This will clear all offline cached data and pending operations. Continue?')) {
                return;
            }

            log('Clearing offline cache...', 'info');
            setButtonLoading('btn-clear-cache', true);

            try {
                await offlineStorage.clearAll();
                log('‚úì Offline cache cleared', 'success');
                showAlert('sync-result', 'Offline cache cleared successfully', 'success');

                // Clear Service Worker cache
                if (serviceWorkerRegistration) {
                    const sw = await navigator.serviceWorker.ready;
                    sw.active.postMessage({ type: 'CLEAR_CACHE' });
                }

                await updateSyncStats();
            } catch (error) {
                log(`‚úó Failed to clear cache: ${error.message}`, 'error');
                showAlert('sync-result', `Failed to clear cache: ${error.message}`, 'error');
            } finally {
                setButtonLoading('btn-clear-cache', false);
            }
        }

        // ========================================
        // END OFFLINE/SYNC FUNCTIONS
        // ========================================

        // Initialize on load
        init();
    </script>
</body>
</html>
